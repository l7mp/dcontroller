package auth

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"math/big"
	"net"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
	rbacv1 "k8s.io/api/rbac/v1"
)

// TokenGenerator generates JWT tokens for users
type TokenGenerator struct {
	privateKey *rsa.PrivateKey
}

// NewTokenGenerator creates a new token generator
func NewTokenGenerator(privateKey *rsa.PrivateKey) *TokenGenerator {
	return &TokenGenerator{privateKey: privateKey}
}

// GenerateToken creates a JWT token for a user with namespace and RBAC rules
func (g *TokenGenerator) GenerateToken(username string, namespaces []string, rules []rbacv1.PolicyRule, expiry time.Duration) (string, error) {
	now := time.Now()
	claims := Claims{
		Username:   username,
		Namespaces: namespaces,
		Rules:      rules,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(now.Add(expiry)),
			IssuedAt:  jwt.NewNumericDate(now),
			NotBefore: jwt.NewNumericDate(now),
			Issuer:    "dcontroller",
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
	return token.SignedString(g.privateKey)
}

// The certificate is valid for the provided hostname (which can be a DNS name or an IP).
// It returns the PEM-encoded certificate and private key as byte slices.
func GenerateSelfSignedCert(hostname string) (certPEM, keyPEM []byte, err error) {
	return GenerateSelfSignedCertWithSANs([]string{hostname})
}

// GenerateSelfSignedCertWithSANs generates a self-signed TLS certificate with multiple SANs.
// The certificate is valid for all provided hostnames/IPs.
// It returns the PEM-encoded certificate and private key as byte slices.
func GenerateSelfSignedCertWithSANs(hostnames []string) (certPEM, keyPEM []byte, err error) {
	// 1. Generate a new RSA private key.
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to generate private key: %w", err)
	}

	// 2. Create a certificate template.
	commonName := "localhost"
	if len(hostnames) > 0 {
		commonName = hostnames[0]
	}

	template := x509.Certificate{
		SerialNumber: big.NewInt(1),
		Subject: pkix.Name{
			CommonName: commonName,
		},
		NotBefore: time.Now(),
		NotAfter:  time.Now().Add(365 * 24 * time.Hour), // Valid for 1 year.

		KeyUsage:    x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
	}

	// 3. Set the Subject Alternative Names (SANs).
	for _, hostname := range hostnames {
		if ip := net.ParseIP(hostname); ip != nil {
			template.IPAddresses = append(template.IPAddresses, ip)
		} else {
			template.DNSNames = append(template.DNSNames, hostname)
		}
	}

	// 4. Create the self-signed certificate bytes.
	certBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &privateKey.PublicKey, privateKey)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create certificate: %w", err)
	}

	// 5. Encode the certificate to the PEM format.
	certPEM = pem.EncodeToMemory(&pem.Block{
		Type:  "CERTIFICATE",
		Bytes: certBytes,
	})

	// 6. Encode the private key to the PEM format.
	keyBytes := x509.MarshalPKCS1PrivateKey(privateKey)
	keyPEM = pem.EncodeToMemory(&pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: keyBytes,
	})

	return certPEM, keyPEM, nil
}

// ParsePrivateKey takes a PEM-encoded private key as a byte slice and returns an *rsa.PrivateKey.
func ParsePrivateKey(keyPEM []byte) (*rsa.PrivateKey, error) {
	block, _ := pem.Decode(keyPEM)
	if block == nil {
		return nil, fmt.Errorf("failed to parse PEM block containing the private key")
	}
	return x509.ParsePKCS1PrivateKey(block.Bytes)
}

// ParsePublicKey takes a PEM-encoded certificate as a byte slice, parses it,
// and returns the *rsa.PublicKey embedded within it.
func ParsePublicKey(certPEM []byte) (*rsa.PublicKey, error) {
	block, _ := pem.Decode(certPEM)
	if block == nil {
		return nil, fmt.Errorf("failed to parse PEM block containing the certificate")
	}

	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		return nil, fmt.Errorf("failed to parse certificate: %w", err)
	}

	publicKey, ok := cert.PublicKey.(*rsa.PublicKey)
	if !ok {
		return nil, fmt.Errorf("certificate does not contain an RSA public key")
	}

	return publicKey, nil
}

// WriteCertAndKey takes PEM-encoded certificate and key data and writes them to the specified files.
func WriteCertAndKey(certFile, keyFile string, certPEM, keyPEM []byte) error {
	if err := os.WriteFile(certFile, certPEM, 0644); err != nil { //nolint:gosec
		return fmt.Errorf("failed to write certificate file: %w", err)
	}
	if err := os.WriteFile(keyFile, keyPEM, 0600); err != nil {
		return fmt.Errorf("failed to write key file: %w", err)
	}
	return nil
}

// LoadPrivateKey reads a PEM-encoded private key file and returns an *rsa.PrivateKey.  It expects
// a file like the one generated by GenerateSelfSignedCert.
func LoadPrivateKey(keyFile string) (*rsa.PrivateKey, error) {
	keyPEM, err := os.ReadFile(keyFile)
	if err != nil {
		return nil, err
	}
	block, _ := pem.Decode(keyPEM)
	if block == nil {
		return nil, fmt.Errorf("failed to parse PEM block containing the private key from %s", keyFile)
	}
	return x509.ParsePKCS1PrivateKey(block.Bytes)
}

// LoadPublicKey reads a PEM-encoded certificate file, parses the certificate, and returns the
// *rsa.PublicKey embedded within it.
func LoadPublicKey(certFile string) (*rsa.PublicKey, error) {
	certPEM, err := os.ReadFile(certFile)
	if err != nil {
		return nil, err
	}
	block, _ := pem.Decode(certPEM)
	if block == nil {
		return nil, fmt.Errorf("failed to parse PEM block containing the certificate from %s", certFile)
	}

	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		return nil, fmt.Errorf("failed to parse certificate: %w", err)
	}

	// Extract the public key from the certificate.
	publicKey, ok := cert.PublicKey.(*rsa.PublicKey)
	if !ok {
		return nil, fmt.Errorf("certificate in %s does not contain an RSA public key", certFile)
	}

	return publicKey, nil
}
